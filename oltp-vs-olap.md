# 第一节 OLTP Vs DW/BI 两个不同的世界
在本章节中，我们旨在说明将敏捷方法运用于数仓设计领域的动机。我们将在文章的开头总结DW/BI系统和业务系统（OLTP）之间的基础性差异，在此基础上进一步解释这两者使用不同数据建模技巧的原因。接着我们会对比ER（Entity-relationship）建模和纬度建模，并解释为什么纬度建模更适合DW/BI系统。与此同时，我们会介绍纬度建模是如何支持增量设计和交付的，毕竟**增量**是敏捷软件开发的核心原则。   

对于熟悉传统纬度建模好处的读者，可以跳过本章节，直接阅读下一节[数仓需求分析和设计](https://github.com/linuxProber/agile-data-warehouse-design/tree/main)。在该章节中我们将会介绍敏捷纬度建模，通过回顾DW/BI的开发流程和审视传统数据需求分析方法，我们强调了传统方法在处理复杂数据源和应对快节奏数仓开发项目时的缺点。而为了解决这种问题，我们积极地让业务利益相关者参与到需求分析和设计过程。在本章的最后，我们将介绍一套利于跨部门协同的纬度建模的敏捷工具 - BEAM（Business Event Analysis and Modeling），该工具带有**协同**、**增量**和**迭代**的重要特性。

OLTP系统和DW/BI系统首先在目的性上就存在根本性不同。OLTP主要是为了支持业务流程的执行，而DW/BI则是为了评估分析业务流程的执行结果。为了提升执行效率，OLTP系统需要在联机交易处理的应用方向上不断优化。相反，数据仓库则需要在查询处理和易用性的方向进行优化。下表突出了两者在使用模式上的重要区别，并从数据管理系统的角度去描述两者需求的差异。   

| 比较纬度  | OLTP数据库 | 数据仓库 |
| ------------- | ------------- | -------- |
| 目的  | 执行独立的业务过程，如下单  | 分析评估多个业务过程，如观察带看量 |
| 事务类型  | insert、select、update、delete |  select |
| 事务风格  | 预定义、可预测、面向稳定的应用  |  不可预测、多变、面向多元的分析 |
| 优化方向  | 更新效率和写一致性  |  查询性能和可用性 |
| 更新频率  | 实时：需要及时相应业务需求  |  近实时：周期性更新 |
| 更新并发度  | 高  |  低 |
| 历史数据访问情况  | 当前和近段时期的数据  |  当前和近几年的数据 |
| 选择粒度  | 精准和微观实体  |  模糊和宏观群体 |
| 比较频率  | 低频  |  高频 |
| 查询条件复杂度  | 低  |  高 |
| 每事务的Join数量  | 低（1-3）  |  高（10+） |
| 每事务涉及记录数  | 十来条  |  百万级 |
| 日均事务数  | 百万级  |  上千条 |
| 数据量  | GB-TB  |  TB-PB |
| 数据类型  | 主要是原始明细数据  |  明细数据、汇总数据和衍生数据 |



## 案例：ER建模的问题
ER建模是OLTP系统数据库设计的标准方法。
该方法将所有的数据类型分成了实体（entity）、关系（relationship）和属性（attribute）三种。
图1-1展示了实体级ER图的示例。图中实体用方块表示，关系则使用方块间连线来表示。
![image](https://user-images.githubusercontent.com/20431533/111636369-5d99c400-8833-11eb-969a-18ab8bd780e1.png)   
图1-1   
每对关系的基数（1对1的关系、1对多的关系和多对多的关系）则是在边的两端用不同的符号表示，如 | 表示1，O 表示0或者可选择，“鱼尾”则表示多个。
举例，每位房产经纪人在一段时间内只能一个门店入职，则经纪人实体和门店实体之间的关系是1对1；每位房产经纪人在一段时间内可能售出多套二手房源，则经纪人实体和房源实体之间是“1对多”的人关系；

在关系型数据库中，实体对应的是数据库表，属性对应的则是数据库表的列。
关系则可以使用表示实体的数据库表的列或者额外的数据库表的列来表示。
比如经纪人和身份信息是1:1的关系，则在经纪人表和身份信息表上可各有一列来存放对方的外链；比如经纪人和维护房源是1:N的关系，则在房源表上有一列存放经纪人的外链；再比如产品和订单之间是M:N的关系，则需要有一张额外的映射表来存放产品外链和订单外链的对应关系。

ER建模常常和范式化有关，尤其是第三范式。ER建模和范式化的技术目标很明确：尽可能降低数据冗余和显式描述数据里的1:1和1:N的关系。而这些要求目前也已经被RDMS系统所强制实现。  

### ER建模应用于OLTP的优势 
**第三范式（3NF）对于事务处理是高效的。**   
OLTP需要写事务（insert、updates、deletes）非常高效。通过遵循3NF降低数据冗余，事务操作保持了最大限度的小和简单。   
譬如，通过引用C用户记录和S电信服务记录，就可表示C用户反复使用S电信服务的事务操作，而不需要每次都记录C用户和S电信服务的详细信息。而当C用户或者S服务的信息需要改变时，只需更改对应用户表或者服务表上的一条记录信息即可。假如我们并非通过引用记录而是通过不断复制记录副本的方式来记录事务，则更改信息时极有可能由于副本更改不完全而导致数据库状态的不一致。除了3NF之外，还有其他更高阶的范式，但3NF已能满足大部分ER建模人员的实际需求。对于3NF，关系型模型的发明者Edgar (Ted) Codd有一句非常著名的言论：“The key, the whole key, and nothing but the key, so help 
me Codd”。
 
### ER建模应用于数据仓库的缺点   
**3NF在查询处理方面的表现较为低效**   
虽然3NF有利于数据写入操作，但不利于数据读出操作，这使得3NF在数据仓库和BI应用方面有不可忽视的缺点。范式使得数据库表倾向于拆分成多个不同的实体类别，而JOIN查询多个数据库表的效率较低且易导致编码错误。   
譬如，回顾图1-1，读者能想象将**PRODUCT CATEGORY**连接（JOIN）到**ORDER**的方式有多少种吗？在实现了**PRODUCT CATEGORY**和**ORDER**之间的M:M的关系的3NF物理数据库表上，需要连接（JOIN）至少20张表。   
总的来说，当我们使用基于3NF的数据库时，即使是最简单的BI查询，往往也需要多张表连接另外的中间表。这些冗长的连接（JOIN）路径不仅难以优化而且运行起来及其缓慢。
**3NF模型不容易理解**   
更重要的，BI用户的查询只有正确使用连接（JOIN）路径时才能产生正确结果，也就是说，需要使用SQL语言问出正确的问题。如果使用了错误的连接（JOIN）路径，那么BI用户会在不知情的情况下得到其他无意义问题的答案。3NF无论是对人还是机器来说都是相对复杂的，虽然近些年数据仓库设备（专家硬件）在不断优化查询性能，但对人类而言复杂性是更加难以处理的问题。虽然智能BI软件能将数据库模式的复杂性隐藏在易用的交互下方，但也仅仅是将理解3NF的负担从BI用户的查询端转移到BI开发者的配置端。这虽然也算是进步，但对业务相关利益者（业务人员、BI用户、BI开发者、数据产品经理和数据工程师等）而言，3NF模型在回顾和质量保障（QA）方面的复杂度还是过大。   
## 案例：纬度建模   

### 星型建模   

### 事实表和纬度表

### 纬度建模应用于数据仓库的优势
